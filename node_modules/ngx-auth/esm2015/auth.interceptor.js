/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Injectable, Injector } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Subject, throwError } from 'rxjs';
import { map, first, switchMap, catchError } from 'rxjs/operators';
import { AUTH_SERVICE } from './tokens';
export class AuthInterceptor {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
        /**
         * Is refresh token is being executed
         */
        this.refreshInProgress = false;
        /**
         * Notify all outstanding requests through this subject
         */
        this.refreshSubject = new Subject();
    }
    /**
     * Intercept an outgoing `HttpRequest`
     * @param {?} req
     * @param {?} delegate
     * @return {?}
     */
    intercept(req, delegate) {
        if (this.skipRequest(req)) {
            return delegate.handle(req);
        }
        return this.processIntercept(req, delegate);
    }
    /**
     * Process all the requests via custom interceptors.
     * @param {?} original
     * @param {?} delegate
     * @return {?}
     */
    processIntercept(original, delegate) {
        /** @type {?} */
        const clone = original.clone();
        return this.request(clone)
            .pipe(switchMap((req) => delegate.handle(req)), catchError((res) => this.responseError(clone, res)));
    }
    /**
     * Request interceptor. Delays request if refresh is in progress
     * otherwise adds token to the headers
     * @param {?} req
     * @return {?}
     */
    request(req) {
        if (this.refreshInProgress) {
            return this.delayRequest(req);
        }
        return this.addToken(req);
    }
    /**
     * Failed request interceptor, check if it has to be processed with refresh
     * @param {?} req
     * @param {?} res
     * @return {?}
     */
    responseError(req, res) {
        /** @type {?} */
        const authService = this.injector.get(AUTH_SERVICE);
        /** @type {?} */
        const refreshShouldHappen = authService.refreshShouldHappen(res);
        if (refreshShouldHappen && !this.refreshInProgress) {
            this.refreshInProgress = true;
            authService
                .refreshToken()
                .subscribe(() => {
                this.refreshInProgress = false;
                this.refreshSubject.next(true);
            }, () => {
                this.refreshInProgress = false;
                this.refreshSubject.next(false);
            });
        }
        if (refreshShouldHappen && this.refreshInProgress) {
            return this.retryRequest(req, res);
        }
        return throwError(res);
    }
    /**
     * Add access token to headers or the request
     * @param {?} req
     * @return {?}
     */
    addToken(req) {
        /** @type {?} */
        const authService = this.injector.get(AUTH_SERVICE);
        return authService.getAccessToken()
            .pipe(map((token) => {
            if (token) {
                /** @type {?} */
                let setHeaders;
                if (typeof authService.getHeaders === 'function') {
                    setHeaders = authService.getHeaders(token);
                }
                else {
                    setHeaders = { Authorization: `Bearer ${token}` };
                }
                return req.clone({ setHeaders });
            }
            return req;
        }), first());
    }
    /**
     * Delay request, by subscribing on refresh event, once it finished, process it
     * otherwise throw error
     * @param {?} req
     * @return {?}
     */
    delayRequest(req) {
        return this.refreshSubject.pipe(first(), switchMap((status) => status ? this.addToken(req) : throwError(req)));
    }
    /**
     * Retry request, by subscribing on refresh event, once it finished, process it
     * otherwise throw error
     * @param {?} req
     * @param {?} res
     * @return {?}
     */
    retryRequest(req, res) {
        /** @type {?} */
        const http = this.injector.get(HttpClient);
        return this.refreshSubject.pipe(first(), switchMap((status) => status ? http.request(req) : throwError(res || req)));
    }
    /**
     * Checks if request must be skipped by interceptor.
     * @param {?} req
     * @return {?}
     */
    skipRequest(req) {
        /** @type {?} */
        const skipRequest = this.exec('skipRequest', req);
        /** @type {?} */
        const verifyRefreshToken = this.exec('verifyRefreshToken', req);
        // deprecated, will be removed soon
        /** @type {?} */
        const verifyTokenRequest = this.exec('verifyTokenRequest', req.url);
        return skipRequest || verifyRefreshToken || verifyTokenRequest;
    }
    /**
     * Exec optional method, will be removed in upcoming updates.
     * Temp method until `verifyTokenRequest` will be completely replaced with skipRequest
     * @param {?} method
     * @param {...?} args
     * @return {?}
     */
    exec(method, ...args) {
        /** @type {?} */
        const authService = this.injector.get(AUTH_SERVICE);
        if (typeof authService[method] === 'function') {
            return authService[method](...args);
        }
    }
}
AuthInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AuthInterceptor.ctorParameters = () => [
    { type: Injector }
];
if (false) {
    /**
     * Is refresh token is being executed
     * @type {?}
     */
    AuthInterceptor.prototype.refreshInProgress;
    /**
     * Notify all outstanding requests through this subject
     * @type {?}
     */
    AuthInterceptor.prototype.refreshSubject;
    /** @type {?} */
    AuthInterceptor.prototype.injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1hdXRoLyIsInNvdXJjZXMiOlsiYXV0aC5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxFQUNMLFVBQVUsRUFNWCxNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxPQUFPLEVBQWMsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3ZELE9BQU8sRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUduRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBR3hDLE1BQU0sT0FBTyxlQUFlOzs7O0lBWTFCLFlBQW9CLFFBQWtCO1FBQWxCLGFBQVEsR0FBUixRQUFRLENBQVU7Ozs7UUFQOUIsc0JBQWlCLEdBQUcsS0FBSyxDQUFDOzs7O1FBSzFCLG1CQUFjLEdBQXFCLElBQUksT0FBTyxFQUFXLENBQUM7SUFFekIsQ0FBQzs7Ozs7OztJQUtuQyxTQUFTLENBQ2QsR0FBcUIsRUFDckIsUUFBcUI7UUFFckIsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3pCLE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM3QjtRQUVELE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUM5QyxDQUFDOzs7Ozs7O0lBS08sZ0JBQWdCLENBQ3RCLFFBQTBCLEVBQzFCLFFBQXFCOztjQUVmLEtBQUssR0FBcUIsUUFBUSxDQUFDLEtBQUssRUFBRTtRQUVoRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO2FBQ3ZCLElBQUksQ0FDSCxTQUFTLENBQUMsQ0FBQyxH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Q0FBQyxRQUFRLENBQUMsR0FBRyxDQUFhLFVBQVUsQ0FBQztRQUUzQyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUM3QixLQUFLLEVBQUUsRUFDUCxTQUFTLENBQUMsQ0FBQyxNQUFlLEVBQUUsRUFBRSxDQUM1QixNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQ3BELENBQ0YsQ0FBQztJQUNKLENBQUM7Ozs7OztJQUtPLFdBQVcsQ0FBQyxHQUFxQjs7Y0FDakMsV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLEdBQUcsQ0FBQzs7Y0FDM0Msa0JBQWtCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLENBQUM7OztjQUd6RCxrQkFBa0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUM7UUFFbkUsT0FBTyxXQUFXLElBQUksa0JBQWtCLElBQUksa0JBQWtCLENBQUM7SUFDakUsQ0FBQzs7Ozs7Ozs7SUFNTyxJQUFJLENBQUMsTUFBYyxFQUFFLEdBQUcsSUFBVzs7Y0FDbkMsV0FBVyxHQUNmLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFjLFlBQVksQ0FBQztRQUU5QyxJQUFJLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLFVBQVUsRUFBRTtZQUM3QyxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1NBQ3JDO0lBQ0gsQ0FBQzs7O1lBakxGLFVBQVU7Ozs7WUFmVSxRQUFROzs7Ozs7O0lBcUIzQiw0Q0FBa0M7Ozs7O0lBS2xDLHlDQUFrRTs7SUFFdEQsbUNBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEh0dHBDbGllbnQsXG4gIEh0dHBFdmVudCxcbiAgSHR0cEludGVyY2VwdG9yLFxuICBIdHRwSGFuZGxlcixcbiAgSHR0cFJlcXVlc3QsXG4gIEh0dHBFcnJvclJlc3BvbnNlXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IFN1YmplY3QsIE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgZmlyc3QsIHN3aXRjaE1hcCwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQXV0aFNlcnZpY2UgfSBmcm9tICcuL2F1dGguc2VydmljZSc7XG5pbXBvcnQgeyBBVVRIX1NFUlZJQ0UgfSBmcm9tICcuL3Rva2Vucyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBdXRoSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuXG4gIC8qKlxuICAgKiBJcyByZWZyZXNoIHRva2VuIGlzIGJlaW5nIGV4ZWN1dGVkXG4gICAqL1xuICBwcml2YXRlIHJlZnJlc2hJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIE5vdGlmeSBhbGwgb3V0c3RhbmRpbmcgcmVxdWVzdHMgdGhyb3VnaCB0aGlzIHN1YmplY3RcbiAgICovXG4gIHByaXZhdGUgcmVmcmVzaFN1YmplY3Q6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yKSB7fVxuXG4gIC8qKlxuICAgKiBJbnRlcmNlcHQgYW4gb3V0Z29pbmcgYEh0dHBSZXF1ZXN0YFxuICAgKi9cbiAgcHVibGljIGludGVyY2VwdChcbiAgICByZXE6IEh0dHBSZXF1ZXN0PGFueT4sXG4gICAgZGVsZWdhdGU6IEh0dHBIYW5kbGVyXG4gICk6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBpZiAodGhpcy5za2lwUmVxdWVzdChyZXEpKSB7XG4gICAgICByZXR1cm4gZGVsZWdhdGUuaGFuZGxlKHJlcSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0ludGVyY2VwdChyZXEsIGRlbGVnYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFsbCB0aGUgcmVxdWVzdHMgdmlhIGN1c3RvbSBpbnRlcmNlcHRvcnMuXG4gICAqL1xuICBwcml2YXRlIHByb2Nlc3NJbnRlcmNlcHQoXG4gICAgb3JpZ2luYWw6IEh0dHBSZXF1ZXN0PGFueT4sXG4gICAgZGVsZWdhdGU6IEh0dHBIYW5kbGVyXG4gICk6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBjb25zdCBjbG9uZTogSHR0cFJlcXVlc3Q8YW55PiA9IG9yaWdpbmFsLmNsb25lKCk7XG5cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGNsb25lKVxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCgocmVxOiBIdHRwUmVxdWVzdDxhbnk+KSA9PiBkZWxlZ2F0ZS5oYW5kbGUocmVxKSksXG4gICAgICAgIGNhdGNoRXJyb3IoKHJlczogSHR0cEVycm9yUmVzcG9uc2UpID0+IHRoaXMucmVzcG9uc2VFcnJvcihjbG9uZSwgcmVzKSlcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCBpbnRlcmNlcHRvci4gRGVsYXlzIHJlcXVlc3QgaWYgcmVmcmVzaCBpcyBpbiBwcm9ncmVzc1xuICAgKiBvdGhlcndpc2UgYWRkcyB0b2tlbiB0byB0aGUgaGVhZGVyc1xuICAgKi9cbiAgcHJpdmF0ZSByZXF1ZXN0KHJlcTogSHR0cFJlcXVlc3Q8YW55Pik6IE9ic2VydmFibGU8SHR0cFJlcXVlc3Q8YW55Pj4ge1xuICAgIGlmICh0aGlzLnJlZnJlc2hJblByb2dyZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxheVJlcXVlc3QocmVxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hZGRUb2tlbihyZXEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhaWxlZCByZXF1ZXN0IGludGVyY2VwdG9yLCBjaGVjayBpZiBpdCBoYXMgdG8gYmUgcHJvY2Vzc2VkIHdpdGggcmVmcmVzaFxuICAgKi9cbiAgcHJpdmF0ZSByZXNwb25zZUVycm9yKFxuICAgIHJlcTogSHR0cFJlcXVlc3Q8YW55PixcbiAgICByZXM6IEh0dHBFcnJvclJlc3BvbnNlXG4gICk6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBjb25zdCBhdXRoU2VydmljZTogQXV0aFNlcnZpY2UgPVxuICAgICAgdGhpcy5pbmplY3Rvci5nZXQ8QXV0aFNlcnZpY2U+KEFVVEhfU0VSVklDRSk7XG4gICAgY29uc3QgcmVmcmVzaFNob3VsZEhhcHBlbjogYm9vbGVhbiA9XG4gICAgICBhdXRoU2VydmljZS5yZWZyZXNoU2hvdWxkSGFwcGVuKHJlcyk7XG5cbiAgICBpZiAocmVmcmVzaFNob3VsZEhhcHBlbiAmJiAhdGhpcy5yZWZyZXNoSW5Qcm9ncmVzcykge1xuICAgICAgdGhpcy5yZWZyZXNoSW5Qcm9ncmVzcyA9IHRydWU7XG5cbiAgICAgIGF1dGhTZXJ2aWNlXG4gICAgICAgIC5yZWZyZXNoVG9rZW4oKVxuICAgICAgICAuc3Vic2NyaWJlKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFN1YmplY3QubmV4dCh0cnVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFN1YmplY3QubmV4dChmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChyZWZyZXNoU2hvdWxkSGFwcGVuICYmIHRoaXMucmVmcmVzaEluUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChyZXEsIHJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRocm93RXJyb3IocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYWNjZXNzIHRva2VuIHRvIGhlYWRlcnMgb3IgdGhlIHJlcXVlc3RcbiAgICovXG4gIHByaXZhdGUgYWRkVG9rZW4ocmVxOiBIdHRwUmVxdWVzdDxhbnk+KTogT2JzZXJ2YWJsZTxIdHRwUmVxdWVzdDxhbnk+PiB7XG4gICAgY29uc3QgYXV0aFNlcnZpY2U6IEF1dGhTZXJ2aWNlID1cbiAgICAgIHRoaXMuaW5qZWN0b3IuZ2V0PEF1dGhTZXJ2aWNlPihBVVRIX1NFUlZJQ0UpO1xuXG4gICAgcmV0dXJuIGF1dGhTZXJ2aWNlLmdldEFjY2Vzc1Rva2VuKClcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoKHRva2VuOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGxldCBzZXRIZWFkZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXSB9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1dGhTZXJ2aWNlLmdldEhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc2V0SGVhZGVycyA9IGF1dGhTZXJ2aWNlLmdldEhlYWRlcnModG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0SGVhZGVycyA9IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSh7IHNldEhlYWRlcnMgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpcnN0KClcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVsYXkgcmVxdWVzdCwgYnkgc3Vic2NyaWJpbmcgb24gcmVmcmVzaCBldmVudCwgb25jZSBpdCBmaW5pc2hlZCwgcHJvY2VzcyBpdFxuICAgKiBvdGhlcndpc2UgdGhyb3cgZXJyb3JcbiAgICovXG4gIHByaXZhdGUgZGVsYXlSZXF1ZXN0KHJlcTogSHR0cFJlcXVlc3Q8YW55Pik6IE9ic2VydmFibGU8SHR0cFJlcXVlc3Q8YW55Pj4ge1xuICAgIHJldHVybiB0aGlzLnJlZnJlc2hTdWJqZWN0LnBpcGUoXG4gICAgICBmaXJzdCgpLFxuICAgICAgc3dpdGNoTWFwKChzdGF0dXM6IGJvb2xlYW4pID0+XG4gICAgICAgIHN0YXR1cyA/IHRoaXMuYWRkVG9rZW4ocmVxKSA6IHRocm93RXJyb3IocmVxKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cnkgcmVxdWVzdCwgYnkgc3Vic2NyaWJpbmcgb24gcmVmcmVzaCBldmVudCwgb25jZSBpdCBmaW5pc2hlZCwgcHJvY2VzcyBpdFxuICAgKiBvdGhlcndpc2UgdGhyb3cgZXJyb3JcbiAgICovXG4gIHByaXZhdGUgcmV0cnlSZXF1ZXN0KFxuICAgIHJlcTogSHR0cFJlcXVlc3Q8YW55PixcbiAgICByZXM6IEh0dHBFcnJvclJlc3BvbnNlXG4gICk6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBjb25zdCBodHRwOiBIdHRwQ2xpZW50ID1cbiAgICAgIHRoaXMuaW5qZWN0b3IuZ2V0PEh0dHBDbGllbnQ+KEh0dHBDbGllbnQpO1xuXG4gICAgcmV0dXJuIHRoaXMucmVmcmVzaFN1YmplY3QucGlwZShcbiAgICAgIGZpcnN0KCksXG4gICAgICBzd2l0Y2hNYXAoKHN0YXR1czogYm9vbGVhbikgPT5cbiAgICAgICAgc3RhdHVzID8gaHR0cC5yZXF1ZXN0KHJlcSkgOiB0aHJvd0Vycm9yKHJlcyB8fCByZXEpXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcmVxdWVzdCBtdXN0IGJlIHNraXBwZWQgYnkgaW50ZXJjZXB0b3IuXG4gICAqL1xuICBwcml2YXRlIHNraXBSZXF1ZXN0KHJlcTogSHR0cFJlcXVlc3Q8YW55Pikge1xuICAgIGNvbnN0IHNraXBSZXF1ZXN0ID0gdGhpcy5leGVjKCdza2lwUmVxdWVzdCcsIHJlcSk7XG4gICAgY29uc3QgdmVyaWZ5UmVmcmVzaFRva2VuID0gdGhpcy5leGVjKCd2ZXJpZnlSZWZyZXNoVG9rZW4nLCByZXEpO1xuXG4gICAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIHNvb25cbiAgICBjb25zdCB2ZXJpZnlUb2tlblJlcXVlc3QgPSB0aGlzLmV4ZWMoJ3ZlcmlmeVRva2VuUmVxdWVzdCcsIHJlcS51cmwpO1xuXG4gICAgcmV0dXJuIHNraXBSZXF1ZXN0IHx8IHZlcmlmeVJlZnJlc2hUb2tlbiB8fCB2ZXJpZnlUb2tlblJlcXVlc3Q7XG4gIH1cblxuICAvKipcbiAgICogRXhlYyBvcHRpb25hbCBtZXRob2QsIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyB1cGRhdGVzLlxuICAgKiBUZW1wIG1ldGhvZCB1bnRpbCBgdmVyaWZ5VG9rZW5SZXF1ZXN0YCB3aWxsIGJlIGNvbXBsZXRlbHkgcmVwbGFjZWQgd2l0aCBza2lwUmVxdWVzdFxuICAgKi9cbiAgcHJpdmF0ZSBleGVjKG1ldGhvZDogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIGNvbnN0IGF1dGhTZXJ2aWNlOiBBdXRoU2VydmljZSA9XG4gICAgICB0aGlzLmluamVjdG9yLmdldDxBdXRoU2VydmljZT4oQVVUSF9TRVJWSUNFKTtcblxuICAgIGlmICh0eXBlb2YgYXV0aFNlcnZpY2VbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGF1dGhTZXJ2aWNlW21ldGhvZF0oLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbn1cbiJdfQ==